I implement a pre-emptive thread scheduler.  The API functions are:

thread_create: takes a stack pointer, a work function, and user input to the
work function.  When the work function returns, the thread dies.  (I don't
provide a function for exiting a thread---it's not too hard to write one in
any case.)

yield: Yields.  It's implemented as a syscall, to unify the yielding and
pre-emption mechanisms.


There is a single instruction at which stacks are switched.  So, by using the
function call stack, I don't have to save %eip.  By using pusha and popa in
the re-scheduling interrupt, I don't have to save the other general-purpose
registers either.  All that has to be stored is $esp.  (Note that %ebp is on
the stack.  %esp is also on the stack, but it's ignored during popa.)

Every thread has 'thread_top' as its top stack frame.  Every non-running
thread has 'yield_isr' as its bottom stack frame.  When new threads are
created, the thread_create function forges those two stack frames so that the
resume function can be used to start execution as well.


My pre-emption policy is: At every schedule call, I set the timer to send an
interrupt after 50ms, cancelling any previous timer.  Then, upon that
interrupt, I reschedule.  So, only if a single thread takes 50ms consecutively
do I preempt it.  Additionally, keystrokes pre-empt the running thread, though
the test case doesn't make it easy to test this.

My scheduling policy is: Round-robin, with threads occurring in the order they
were created.  No preference is given to threads that yield instead of timing
out.


My test case has four threads.  Two of them print a single character and then
yield, in a loop.  The other two print a single character and then spin for a
large number of cycles.  The result is that four different characters are
interspersed.

